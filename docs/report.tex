\documentclass{article}

\usepackage[hidelinks]{hyperref}
\begin{document}

\begin{titlepage}
    \centering
    {\bfseries\LARGE Universidad de La Habana \par}
    \vspace{1cm}
    {\scshape\Large Facultad de Matemática y Computación \par}
    \vspace{3cm}
    {\scshape\Huge Primer Proyecto de Simulación (Inventario) \par}
    \vfill
   
    {\Large Anabel Benítez González C-411 \par}
    {\Large Raudel Alejandro Gómez Molina C-411 \par}
    \vfill
    {\href{https://github.com/anabel02/discrete-event-simulation}{Proyecto en github} \par}
\end{titlepage}

\section*{Introducción}

Este proyecto tiene como objetivo desarrollar una simulación de eventos discretos para analizar y entender mejor ciertos
fenómenos. A través de este trabajo, buscamos aplicar los principios de la simulación de eventos discretos para modelar
y experimentar con estos fenómenos, y obtener resultados que nos ayuden a tomar decisiones informadas.


\section*{ Breve descripción del proyecto}

Este proyecto tiene como objetivo desarrollar una simulación de eventos discretos para analizar y entender mejor ciertos
fenómenos. A través de este trabajo, buscamos aplicar los principios de la simulación de eventos discretos para modelar
y experimentar con estos fenómenos, y obtener resultados que nos ayuden a tomar decisiones informadas:

\begin{itemize}
    \item Objetivos y metas
    \item El sistema específico a simular. ¿Qué es lo que se está simulando?
\end{itemize}

Para satisfacer las demandas, el tendero debe mantener una cantidad del producto a mano, y siempre que el inventario a
mano se vuelve bajo, se ordenan unidades adicionales al distribuidor. El tendero utiliza una política de pedido
llamada (s, S); es decir, siempre que el inventario a mano es menor que $s$ y no hay un pedido pendiente, entonces se
ordena una cantidad para llevarlo hasta S, donde $s<S$. Es decir, si el nivel de inventario actual es $x$ y no hay un
pedido pendiente, entonces si $x<s$ se ordena la cantidad $S-x$.
El costo de pedir y unidades del producto es una función especificada $c(y)$, y toma $L$ unidades de tiempo hasta que se
entrega el pedido, con el pago realizado a la entrega. Además, la tienda paga un costo de mantenimiento de inventario de
h por unidad de artículo por unidad de tiempo.
Supongamos además que siempre que un cliente demanda más del producto de lo que está disponible actualmente, entonces se
vende la cantidad a mano y el resto del pedido se pierde para la tienda.

El tendero está interesado en determinar el costo total esperado por unidad de tiempo para satisfacer la demanda del
producto:


\begin{itemize}
     
    \item Parámetros del sistema:
    \begin{itemize}
        \item  Tiempo máximo de la simulación ($t_{max}$).
        \item  Distribución del tiempo entre llegadas de los clientes ($T$).
        \item  Distribución de la demanda de los clientes para cada producto ($D$).
        \item  $s$, $S$, $L$, $h$, $c(y)$ para cada producto, $s_i$ es el nivel mínimo que debe alcanzar el producto $i$, $S_i$ es el nivel máximo que debe alcanzar el producto $i$, $L_i$ es el tiempo que toma en llegar el pedido del producto $i$,$h_i$ es el costo de mantenimiento de inventario por unidad de artículo por unidad de tiempo, $c_i(y)$ es el costo de pedir y unidades del producto $i$.
        \item Cantidad inicial de inventario ($I_0$).
        \item Cantidad inicial de dinero ($M_0$).
    \item \end{itemize}
    

    \item Variables de interés:
    \begin{itemize}
        \item Tiempo esperado en el que la ganancia supera una cantidad  (esta cantidad pudiera ser la inversión inicial)
        \item Tiempo esperado en que el negocio quiebra (se queda sin dinero)
        \item Costo total esperado por unidad de tiempo para satisfacer la demanda del producto
    \end{itemize}
\end{itemize}

\section*{Detalles de la implementación}

En el directorio source se encuentran los archivos que contienen el código fuente de la simulación. El archivo \textbf{main.py}
es el punto de entrada de la simulación.
El módulo \textbf{simulation} contiene una abstractación de la simulación, y el módulo \textbf{inventory} contiene la implementación
para nuestro problema específico.

\subsection*{Simulation}

Contiene una implementación general de la simulación de eventos discretos.\\

En \textbf{core.py} encontramos:

\begin{itemize}
    \item La clase \textbf{Event} que representa un evento en la simulación. Cada evento tiene un tiempo asociado y una función \textbf{action} que ejecuta el evento.
    \item La clase \textbf{State} que representa el estado de la simulación.
    \item La clase \textbf{ActionByTime} que representa una acción que se ejecutará antes de cada evento programado.
\end{itemize}

En \textbf{simulator.py} encontramos:

\begin{itemize}
    \item La función \textbf{simulation} que recibe como parámetros una cola con prioridad de eventos, una instancia de \textbf{ActionByTime},
  el estado
  inicial de la simulación, el tiempo máximo de la simulación y una función que determina si la simulación debe
  detenerse. La función ejecuta la simulación de la siguiente manera:
  Mientras haya eventos en la cola, se extrae el primer evento, si el tiempo del evento es menor o igual al tiempo
  máximo de la simulación, se ejecuta la acción de \textbf{ActionByTime}, luego se revisa si se cumple el caso de parada, en caso
  negativo se ejecuta el evento y se actualiza el estado de la simulación, y se vuelve a revisar si se cumple el caso de
  parada con este nuevo estado.
    \item La simulación se detiene por alguno de los siguientes 3 motivos:
    \begin{itemize}
        \item Se alcanza el tiempo máximo de la simulación.
        \item Se cumple el caso de parada definido en \textbf{stop\_case}.
        \item Se terminan los eventos programados.
    \end{itemize}
\end{itemize}

\subsection*{Inventory}

Contiene la implementación específica de \textbf{simulation} para el problema de inventario.\\

En \textbf{inventory.py} se definen:

\begin{itemize}
    \item La clase \textbf{InventoryState} que representa el estado del inventario.
    \item La clase \textbf{RefillEvent} que representa el evento de reabastecimiento del inventario.
    \item La clase \textbf{SaleEvent} que representa el evento de venta de un producto.
    \item La clase \textbf{InventoryConfig} que representa la configuración del inventario.
    \item La clase \textbf{ActionByTimeInventory} que representa la característica de nuestro problema de pagar el costo de
  mantenimiento de inventario por unidad de artículo por unidad de tiempo.
\end{itemize}

En \textbf{inventory\_simulation.py} se define:

\begin{itemize}
    \item La función \textbf{inventory\_simulation} que recibe como parámetros el tiempo máximo de la simulación, la distribución del
  tiempo entre llegadas de los clientes, la lista con configuraciones del inventario, la distribución de la demanda de
  los clientes
  para cada producto, la cantidad inicial de cada producto en el inventario, la cantidad inicial de dinero y una función
  que determina si
  la simulación debe detenerse.
  La función primeramente verifica la consistencia de los parámetros (revisa que las listas que describen los productos
  tengan igual tamaño), luego inicializa el estado de la simulación, crea la cola con prioridad de eventos y ejecuta la
  simulación descrita en el módulo anterior.

    \item  ¿Cómo se crea la cola de eventos?
  Se inicializa una lista vacía.
  Por cada producto en la lista de configuraciones del inventario, se agregan eventos de venta hasta que el tiempo del
  evento sea mayor al tiempo máximo de la simulación.
  Se ordena la lista de eventos por tiempo y se devuelve.
\end{itemize}


\end{document}